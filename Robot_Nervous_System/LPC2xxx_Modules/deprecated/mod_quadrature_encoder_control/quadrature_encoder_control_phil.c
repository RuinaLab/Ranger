/*
 Quadrature Encoder Control (QEC) Module
 
 Phillip Johnson- March 2009
 Cornell University

 Contains the following Functions:
	 init_encoder_tracking: initialize timer0 capture interrupts to enable encoder position and velocity tracking - 
	 -needs to be called by hardware_setup.c
	 
	 update_encoder_position
	 
	 time_counter
 
 Note: define statements for this function are prefaced with "QEC_"

*/

//INCLUDE STATEMENTS:-----------------------------------------------------------------------------------							 
#include <includes.h>   

//*******************************************************************************
// Global Variables
//*******************************************************************************
//Position Tracking Variables:
unsigned volatile int prev_value_A;
unsigned volatile int prev_value_B;
signed volatile long int encoder_count_1;
//Velocity Calculation Variables:
unsigned volatile int timer_values_1[QEC_BUFFER_LENGTH + 1];		//stores captured values of timer0 
unsigned volatile char timer_overflows_1[QEC_BUFFER_LENGTH + 1];	//keeps track of timer overflows
signed volatile char motion_recorded_1[QEC_BUFFER_LENGTH + 1];   	//records direction of previous motor motion for vel. calculation
unsigned int volatile buffer_index_1 = 0;
unsigned int volatile velocity_buffer_overflow_1 = 0;
unsigned int previous_buffer_index_1 = QEC_BUFFER_LENGTH;
float velocity_rad_per_s_1 = 0;
unsigned int total_timer_counts_1 = 0;	
signed char encoder_counts_moved_1 = 0;

//Second Encoder (J9 Header):
//Position Tracking Variables:
unsigned volatile int prev_value_C;
unsigned volatile int prev_value_D;
signed volatile long int encoder_count_2;
//Velocity Calculation Variables:
unsigned volatile int timer_values_2[QEC_BUFFER_LENGTH + 1];		//stores captured values of timer0 
unsigned volatile char timer_overflows_2[QEC_BUFFER_LENGTH + 1];	//keeps track of timer overflows
signed volatile char motion_recorded_2[QEC_BUFFER_LENGTH + 1];   	//records direction of previous motor motion for vel. calculation
unsigned int volatile buffer_index_2 = 0;
unsigned int volatile velocity_buffer_overflow_2 = 0;
unsigned int previous_buffer_index_2 = QEC_BUFFER_LENGTH;
float velocity_rad_per_s_2 = 0;
unsigned int total_timer_counts_2 = 0;	
signed char encoder_counts_moved_2 = 0;

int enc_pins;
int qec_interrupt_count = 0;
int qec_last_count = 0;

//*******************************************************************************
// Initialization Function: 
//*******************************************************************************
void QEC_init_encoder_tracking(void)  
{
	//SET UP CAPTURE INTERRUPTS FOR J3 HEADER:
	if (QEC_J3_ENCODER_POSITION_TRACKING){
		//Enable Capture Interrupt For Falling and Rising Edges:
		PINSEL1 &= ~(3<<12);
	    PINSEL1 |= (2<<12);    // set pin 0.22 to capture 0.0
		PINSEL1 &= ~(3<<22);
	    PINSEL1 |= (2<<22);    // set pin 0.27 to capture 0.1
	
	    switch (QEC_J3_RESOLUTION){
			case 4:	 						//Rising and falling for Cap0.0, Rising and falling for Cap0.1
				T0CCR |= (1<<4);			//enable interrupt on falling edges for CAP0.1
			case 3: 						//Rising and falling for Cap0.0, Rising for Cap0.1
				T0CCR |= (1<<3) | (1<<5);	//enable interrupt on rising edges only for CAP0.1
			case 2: 						//Rising and falling for Cap0.0
				T0CCR |= (1<<1);			//enable interrupt on falling edges for CAP0.0
			case 1: 						//Rising for Cap0.0
				T0CCR |= (1<<0) | (1<<2);	//enable interrupt on rising edges only for CAP0.0, ignore CAP0.1 events
				break;
			default: break;
		}
				
		//Clear Interrupt Flags on Cap 0.0 and 0.1:
		T0IR = 1<<4;	//clear flags for CAP 0.0 and CAP 0.1
		T0IR = 1<<5;	//clear flag for CAP 0.1  
	
		//Note: Interrupts generated by TIMER0 are vectored to interrupt service routine in Quadrature_Encoder_Control 
		//by the settings in the timer0 setup function. (TIMER0 assigned to VectAddr1, the second highest vectored irq)
		//This handler is called: TIMER0_ISR_Handler (Changed to FIQ_Handler to use Fast Interrupts)
	
		//READ INITIAL ENCODER VALUES:
		enc_pins = FIO0PIN;
		prev_value_A = enc_pins & QEC_ENC_CHAN_A_HI;
		prev_value_B = enc_pins & QEC_ENC_CHAN_B_HI;
	}
	
	//SET UP CAPTURE INTERRUPTS FOR J9 HEADER:
	if (QEC_J9_ENCODER_POSITION_TRACKING){
	  //Enable Capture Interrupt For Falling and Rising Edges:
	    //PINSEL1_bit.P0_16 = 3;	  //NOTE THIS PIN IS CAPTURE WHEN PINSEL = 3! DO NOT SET TO OUTPUT!
	    //PINSEL1_bit.P0_29 = 2;
		PINSEL1 &= ~(3<<0); //Clear bits 1:0 (P0.16)
		PINSEL1 &= ~(3<<26); //Clear bits 27:26 (P0.29)
		PINSEL1 |= (3<<0); //Set P0.16 to Timer0 Capture 0.2
		PINSEL1 |= (2<<26); //Set P0.29 to Timer0 Capture 0.3
	
		switch (QEC_J9_RESOLUTION){
			case 4:	 						//Rising and falling for Cap0.2, Rising and falling for Cap0.3
				T0CCR |= (1<<10);			//enable interrupt on falling edges for CAP0.3
			case 3: 						//Rising and falling for Cap0.2, Rising for Cap0.3
				T0CCR |= (1<<9) | (1<<11);	//enable interrupt on rising edges only for CAP0.3
			case 2: 						//Rising and falling for Cap0.2
				T0CCR |= (1<<7);			//enable interrupt on falling edges for CAP0.2
			case 1: 						//Rising for Cap0.2
				T0CCR |= (1<<6) | (1<<8);	//enable interrupt on rising edges only for CAP0.2, ignore CAP0.3 events
				break;
			default: break;
		}
				
		T0IR = 1<<6;		//clear flag for CAP 0.2
		T0IR = 1<<7;		//clear flag for CAP 0.3  
	
		//READ INITIAL ENCODER VALUES:
		enc_pins = FIO0PIN;
		prev_value_C = enc_pins & QEC_ENC_CHAN_C_HI;
		prev_value_D = enc_pins & QEC_ENC_CHAN_D_HI;
	}
}

 __forceinline void QEC_update_encoder_position_A(void) 
{
	int enc_a, enc_b;

	//Update Position of J3 Encoder:
	if (QEC_J3_ENCODER_POSITION_TRACKING){

		enc_pins = FIO0PIN;
		enc_a = enc_pins & QEC_ENC_CHAN_A_HI;
		enc_b = enc_pins & QEC_ENC_CHAN_B_HI;

	   	if (QEC_J3_ENCODER_VELOCITY_TRACKING){
			//(Reset Buffer Index after four values have been recorded:
			if (buffer_index_1 == 0) {
				buffer_index_1 = QEC_BUFFER_LENGTH; 
				velocity_buffer_overflow_1++;
			}
			//Decrement Buffer Index:
			else {
				buffer_index_1--;
			}
			//Update Timer Overflows Recorded:
			timer_overflows_1[buffer_index_1] = 0;
		}

		//Increment Encoder Counts:
		if (enc_a) { //a became high
			if (enc_b) { //b is high
				encoder_count_1++;
				if (QEC_J3_ENCODER_VELOCITY_TRACKING) {
					motion_recorded_1[buffer_index_1] = 1;
				} 	 
			}
			else { //b is low
				encoder_count_1--;
				if (QEC_J3_ENCODER_VELOCITY_TRACKING){
					motion_recorded_1[buffer_index_1] = -1;
				} 
			}
		}
		else { // a became low
			if (enc_b) { //b is high
				encoder_count_1--;
				if (QEC_J3_ENCODER_VELOCITY_TRACKING){
					motion_recorded_1[buffer_index_1] = -1;
				} 
			}
			else { //b is low
				encoder_count_1++;
				if (QEC_J3_ENCODER_VELOCITY_TRACKING){
					motion_recorded_1[buffer_index_1] = 1; 
				}
			}
		}

		prev_value_A = enc_a;	//update previous channel a value

		if (QEC_J3_ENCODER_VELOCITY_TRACKING){
			timer_values_1[buffer_index_1] = T0CR0;
		}
					 
		T0IR = 1<<4;	//reset CR0.0 interrupt corresponds to P0.22
	}
}

__forceinline void QEC_update_encoder_position_B(void) 
{
	int enc_a, enc_b;

	//Update Position of J3 Encoder:
	if (QEC_J3_ENCODER_POSITION_TRACKING){

		enc_pins = FIO0PIN;
		enc_a = enc_pins & QEC_ENC_CHAN_A_HI;
		enc_b = enc_pins & QEC_ENC_CHAN_B_HI;

	   	if (QEC_J3_ENCODER_VELOCITY_TRACKING){
			//(Reset Buffer Index after four values have been recorded:
			if (buffer_index_1 == 0) {
				buffer_index_1 = QEC_BUFFER_LENGTH; 
				velocity_buffer_overflow_1++;
			}
			//Decrement Buffer Index:
			else {
				buffer_index_1--;
			}
			//Update Timer Overflows Recorded:
			timer_overflows_1[buffer_index_1] = 0;
		}
		//Increment Encoder Counts:
		if (enc_b) { //b became high
			if (enc_a) { //a is high
				encoder_count_1--;
				if (QEC_J3_ENCODER_VELOCITY_TRACKING) {
					motion_recorded_1[buffer_index_1] = -1;
				} 	 
			}
			else { //a is low
				encoder_count_1++;
				if (QEC_J3_ENCODER_VELOCITY_TRACKING){
					motion_recorded_1[buffer_index_1] = 1;
				} 
			}
		}
		else { // b became low
			if (enc_a) { //a is high
				encoder_count_1++;
				if (QEC_J3_ENCODER_VELOCITY_TRACKING){
					motion_recorded_1[buffer_index_1] = 1;
				} 
			}
			else { //b is low
				encoder_count_1--;
				if (QEC_J3_ENCODER_VELOCITY_TRACKING){
					motion_recorded_1[buffer_index_1] = -1; 
				}
			}
		}

		prev_value_B = enc_b;	//update previous channel b value

		if (QEC_J3_ENCODER_VELOCITY_TRACKING){
			timer_values_1[buffer_index_1] = T0CR1;	//save value of capture register
		}
		
		T0IR = 1<<5;	//reset CR0.2 interrupt corresponds to P0.27
	}
}

__forceinline void QEC_update_encoder_position_C(void)
{
	int enc_c, enc_d;

	//Update Position of J9 Encoder:
	if (QEC_J9_ENCODER_POSITION_TRACKING){

		enc_pins = FIO0PIN;
		enc_c = enc_pins & QEC_ENC_CHAN_C_HI;
		enc_d = enc_pins & QEC_ENC_CHAN_D_HI;

    	if (QEC_J9_ENCODER_VELOCITY_TRACKING){
			//Reset Buffer Index after four values have been recorded:
			if (buffer_index_2 == 0) {
				buffer_index_2 = QEC_BUFFER_LENGTH; 
				velocity_buffer_overflow_2++;
			}
			//Increment Buffer Index:
			else {
				buffer_index_2--;
			}
			//Update Timer Overflows Recorded:
			timer_overflows_2[buffer_index_2] = 0;
		}

		//Increment Encoder Counts:
		if (enc_c) {    //c became high
			if (enc_d) { //d is high
				encoder_count_2--;
			  	if (QEC_J9_ENCODER_VELOCITY_TRACKING){
					motion_recorded_2[buffer_index_2] = 1; 
				}	 
			}
			else {	//d is low		
				encoder_count_2++;
				if (QEC_J9_ENCODER_VELOCITY_TRACKING){
					motion_recorded_2[buffer_index_2] = -1; 
				}
			}
		}
		else {	//c became low
			if (enc_d) { //d is high 
				encoder_count_2++;
				if (QEC_J9_ENCODER_VELOCITY_TRACKING){
					motion_recorded_2[buffer_index_2] = -1; 
				}
			}
			else {
				encoder_count_2--;
				if (QEC_J9_ENCODER_VELOCITY_TRACKING){
					motion_recorded_2[buffer_index_2] = 1; 
				}
			}
		}

		prev_value_C = enc_c;	//update previous channel a value
      	
		if (QEC_J9_ENCODER_VELOCITY_TRACKING){
			timer_values_2[buffer_index_2] = T0CR2;
		}

	    T0IR = 1<<6;	//reset CR0.3 interrupt corresponds to P0.22
	} //check if J9 encoder position is being tracked
}

__forceinline void QEC_update_encoder_position_D(void) 
{
	int enc_c, enc_d;

	//Update Position of J9 Encoder:
	if (QEC_J9_ENCODER_POSITION_TRACKING){

		enc_pins = FIO0PIN;
		enc_c = enc_pins & QEC_ENC_CHAN_C_HI;
		enc_d = enc_pins & QEC_ENC_CHAN_D_HI;

    	if (QEC_J9_ENCODER_VELOCITY_TRACKING){
			//Reset Buffer Index after four values have been recorded:
			if (buffer_index_2 == 0) {
				buffer_index_2 = QEC_BUFFER_LENGTH; 
				velocity_buffer_overflow_2++;
			}
			//Increment Buffer Index:
			else {
				buffer_index_2--;
			}
			//Update Timer Overflows Recorded:
			timer_overflows_2[buffer_index_2] = 0;
		}
		//Increment Encoder Counts:
		if (enc_d) {		//D became high
			if (enc_c) { // C is highh
				encoder_count_2++;
				if (QEC_J9_ENCODER_VELOCITY_TRACKING){
					motion_recorded_2[buffer_index_2] = -1; 
				}
			}
			else { //C is low
				encoder_count_2--;
			  	if (QEC_J9_ENCODER_VELOCITY_TRACKING){
					motion_recorded_2[buffer_index_2] = 1; 
				}
			}
		}
		else {				       //D became low
			if (enc_c) { // C is high
				encoder_count_2--;
				if (QEC_J9_ENCODER_VELOCITY_TRACKING){
					motion_recorded_2[buffer_index_2] = 1; 
				}
			}
			else { //C is low
				encoder_count_2++;
				if (QEC_J9_ENCODER_VELOCITY_TRACKING){
					motion_recorded_2[buffer_index_2] = -1; 
				}
			}
		}
		
		prev_value_D = enc_d;	//update previous channel b value

	  	if (QEC_J9_ENCODER_VELOCITY_TRACKING){
			timer_values_2[buffer_index_2] = T0CR3;
		}

	    T0IR = 1<<7;	//reset CR0.4 interrupt corresponds to P0.27

	}//check if J9 encoder position is being tracked						
}


__forceinline void QEC_time_counter(void) {
//Timer overflow for J3 Encoder:-------------------------------------------------------
   #if QEC_J3_ENCODER_VELOCITY_TRACKING
	//Increment Timer Overflow Count:
		timer_overflows_1[buffer_index_1]++;
	//Check for stopped motor:
		if (timer_overflows_1[buffer_index_1] == QEC_ZERO_VELOCITY_TIMEOUTS) {
    	  //Change Buffer Index: 
	    	//Reset Buffer Index after four values have been recorded:
		    	if (buffer_index_1 == 0) {
				buffer_index_1 = QEC_BUFFER_LENGTH; 
				velocity_buffer_overflow_1++;
				}
		    //Increment Buffer Index:
			    else {buffer_index_1--;}
		 //Write to velocity data buffers:
		 	motion_recorded_1[buffer_index_1] = 0;
			timer_values_1[buffer_index_1]    = 0;
			timer_overflows_1[buffer_index_1] = 0;
		}
   #endif
//Timer overflow for J9 Encoder:-------------------------------------------------------
   #if QEC_J9_ENCODER_VELOCITY_TRACKING
	//Increment Timer Overflow Count:
		timer_overflows_2[buffer_index_2]++;
	//Check for stopped motor:
		if (timer_overflows_2[buffer_index_2] == QEC_zero_velocity_timeouts) {
    	  //Change Buffer Index: 
	    	//Reset Buffer Index after four values have been recorded:
		    	if (buffer_index_2 == 0) {
				buffer_index_2 = QEC_BUFFER_LENGTH; 
				velocity_buffer_overflow_2++;
				}
		    //Increment Buffer Index:
			    else {buffer_index_2--;}
		 //Write to velocity data buffers:
		 	motion_recorded_2[buffer_index_2] = 0;
			timer_values_2[buffer_index_2]    = 0;
			timer_overflows_2[buffer_index_2] = 0;
		}
   #endif
//Reset Interrupt Flag:----------------------------------------------------------------
		T0IR = 1;		//reset match zero interrupt on timer0
}

void QEC_update_velocity_data(void) 
{	
//Function Variables:------------------------------------------------------------------
	#if (QEC_J3_ENCODER_VELOCITY_TRACKING | QEC_J9_ENCODER_VELOCITY_TRACKING)
	unsigned int ii = 0;
	#endif
  //For J3 Encoder Velocity
  	#if QEC_J3_ENCODER_VELOCITY_TRACKING
	unsigned int total_timer_overflows_1 = 0;
	int current_buffer_index_1;
	int loop_buffer_index_1;
	#endif
  //For J9 Encoder Velocity
    #if QEC_J9_ENCODER_VELOCITY_TRACKING  
	unsigned int total_timer_overflows_2 = 0;
	int current_buffer_index_2;
	int loop_buffer_index_2;
	#endif

 //Velocity of J9 Encoder:-------------------------------------------------------------
 	#if QEC_J9_ENCODER_VELOCITY_TRACKING
	 //Read where interrupt function stopped adding values:
	 	ii = 0;
	 	current_buffer_index_2 = buffer_index_2;
		loop_buffer_index_2 = current_buffer_index_2;
		encoder_counts_moved_2 = 0;
	 //Check for buffer overflow:
		#if QEC_overflow_checking
			 	if (velocity_buffer_overflow_2) {
					if (velocity_buffer_overflow_2 > 1) {
  					  #if (global_print_setting & QEC_print)
			//		  	printf("\033[2J\033[H");						// Return cursor to home, clear screen		   					  
//			 			printf("ERROR VELOCITY BUFFER OVERFLOW.\n");		
					  #endif
					}
					if (current_buffer_index_2 < previous_buffer_index_2) {
					  #if (global_print_setting & QEC_print)
			//		  	printf("\033[2J\033[H");						// Return cursor to home, clear screen		   					  
//			 			printf("ERROR VELOCITY BUFFER OVERFLOW.\n");
					  #endif
					}
				}
		#endif
	 //Reset overflow-check constants:
	 	previous_buffer_index_2 = current_buffer_index_2;
		velocity_buffer_overflow_2 = 0;
	 //Calculate total angle moved and total number of timer0 overflows that occured:
		do {
			//Update count:
				ii++;		
			//Sum motion of encoder:
				encoder_counts_moved_2 += motion_recorded_2[loop_buffer_index_2];			
			//Increment Buffer Index in Circular Array:
				if (loop_buffer_index_2 == QEC_BUFFER_LENGTH) {loop_buffer_index_2 = 0;}
				else {loop_buffer_index_2++;}
			//Sum timer0 overflows:
				total_timer_overflows_2 += timer_overflows_2[loop_buffer_index_2];			
		}
		while (ii < num_to_av);
	 //Calculate average between pulses:
		total_timer_counts_2 = total_timer_overflows_2*QEC_timer_reset_value + timer_values_2[current_buffer_index_2]
								- timer_values_2[loop_buffer_index_2];
	 //Check if motor is stopped:
		if (encoder_counts_moved_2 == 0) {
		  #if (QEC_debug_scope_1khz == 0)
			velocity_rad_per_s_2 = 0;
			encoder_counts_moved_2 = 0;
			total_timer_counts_2 = 0;		//dummy value in reality this would be infinity...
		  #endif
		  #if (!(global_print_setting | QEC_debug))
			return;		//average angular velocity is zero
		  #endif
		}
	 //Average timer counts for 4 intervals:
		total_timer_counts_2 = total_timer_counts_2 >> num_to_shift;  //divide by 8

	#endif //check if velocity tracking is enabled for this encoder

 //Velocity of J3 Encoder:-------------------------------------------------------------
 	#if QEC_J3_ENCODER_VELOCITY_TRACKING
	 //Read where interrupt function stopped adding values:
	 	ii = 0;
	 	current_buffer_index_1 = buffer_index_1;
		loop_buffer_index_1 = current_buffer_index_1;
	 //Check for buffer overflow:
		#if QEC_overflow_checking
			 	if (velocity_buffer_overflow_1) {
					if (velocity_buffer_overflow_1 > 1) {
  					  #if (global_print_setting & QEC_print)
			//		  	printf("\033[2J\033[H");						// Return cursor to home, clear screen		   					  
			 			printf("ERROR VELOCITY BUFFER OVERFLOW.\n");		
					  #endif
					}
					if (current_buffer_index_1 < previous_buffer_index_1) {
					  #if (global_print_setting & QEC_print)
			//		  	printf("\033[2J\033[H");						// Return cursor to home, clear screen		   					  
			 			printf("ERROR VELOCITY BUFFER OVERFLOW.\n");
					  #endif
					}
				}
		#endif
	 //Reset overflow-check constants:
	 	previous_buffer_index_1 = current_buffer_index_1;
		velocity_buffer_overflow_1 = 0;
		encoder_counts_moved_1 = 0;
	 //Calculate total angle moved and total number of timer0 overflows that occured:
		do {
			//Update count:
				ii++;		
			//Sum motion of encoder:
				encoder_counts_moved_1 += motion_recorded_1[loop_buffer_index_1];			
			//Increment Buffer Index in Circular Array:
				if (loop_buffer_index_1 == QEC_BUFFER_LENGTH) {loop_buffer_index_1 = 0;}
				else {loop_buffer_index_1++;}
			//Sum timer0 overflows:
				total_timer_overflows_1 += timer_overflows_1[loop_buffer_index_1];			
		}
		while (ii < NUM_TO_AV);
	 //Calculate average between pulses:
		total_timer_counts_1 = total_timer_overflows_1*QEC_TIMER_RESET_VALUE + timer_values_1[current_buffer_index_1]
								- timer_values_1[loop_buffer_index_1];
	 //Check if motor is stopped:
		if (encoder_counts_moved_1 == 0) {
		  #if (QEC_debug_scope_1khz == 0)
			velocity_rad_per_s_1 = 0;
			encoder_counts_moved_1 = 0;
			total_timer_counts_1 = 0;		//dummy value in reality this would be infinity...
		  #endif
		  #if (!(global_print_setting | QEC_debug))
			return;		//average angular velocity is zero
		  #endif
		}
	 //Average timer counts for 4 intervals:
		total_timer_counts_1 = total_timer_counts_1 >> 2;  //divide by 4
/*		if (total_timer_counts_1 > 3000) {
			error_flag++;
				if (error_flag > 10) {
					printf("Total Timer Counts: %i\n\r", total_timer_counts_1);
					printf("error\n");
//					printf("error\n");
				} 
		} */
	#endif //check if velocity tracking is enabled for this encoder
//Print timer count output for debugging:-------------------------------------------------------------
		#if (QEC_print & global_print_setting)
				#if QEC_J3_ENCODER_POSITION_TRACKING
//					printf("Position 1: %i\n", encoder_count_1);
				#endif
				#if QEC_J9_ENCODER_POSITION_TRACKING
//					printf("Position 2: %i\n", encoder_count_2);
				#endif
				#if QEC_J3_ENCODER_VELOCITY_TRACKING
//					printf("Timer Overflows: %i\n\r", total_timer_overflows_1);
//					printf("Encoder Counts Moved: %i\n\r", encoder_counts_moved_1);
//					printf("%i\n", total_timer_counts_1);	
	//				printf("%i %i %i\n", encoder_count_1, encoder_counts_moved_1, total_timer_counts_1);
				#endif
				#if QEC_J9_ENCODER_VELOCITY_TRACKING
					//printf("Relative Counts: %i\n", encoder_count_2);
//					printf("Timer Overflows: %i\n\r", total_timer_overflows_2);
//					printf("Encoder Counts Moved: %i\n\r", encoder_counts_moved_2);
//					printf("Total Timer Counts: %i\n\r", total_timer_counts_2);
//					printf("%i, ", total_timer_counts_2);
//					printf("%i, ", encoder_counts_moved_2);
//					printf("%i, ", encoder_count_2);
					if (total_timer_counts_2 == 544) {
//						printf("Error\n\r");
					}	
	//				printf("%i %i %i\n", encoder_count_2, encoder_counts_moved_2, total_timer_counts_2);
				#endif				
		#endif
}

float QEC_get_floating_point_velocity_1(void) {
	float velocity;
	if (total_timer_counts_1) {
		velocity = ((float)encoder_counts_moved_1/(float)total_timer_counts_1)*CPUSPEED*QEC_2_PI/QEC_COUNTS_PER_REVOLUTION/4;	
	}
	else {velocity = 0;}
	return velocity;
}

float QEC_get_position_radians_1(void)
{
	float position;
	position = (float)(encoder_count_1 * QEC_2_PI * 0.00037202381); //position in radians
	return position;
}

int QEC_get_encoder_counts_moved_1(void) {
 	return encoder_counts_moved_1;
}

int QEC_get_position_1(void) {
	return encoder_count_1;
}

int QEC_get_tot_timer_counts_1(void) 
{
	return total_timer_counts_1;
}

__irq void FIQ_Handler(void) //TIMER0_ISR_Handler(void) //__irq	
{ 
//	FIO0CLR_bit.P0_10=1;	// p0.10 on
	//Determine Source Of Interrupt:
	  if (!(T0IR & 1<<0)) { 	//chech T0IR register timer interrupt
	  	#if QEC_J3_ENCODER_POSITION_TRACKING
			#if (QEC_J3_RESOLUTION > 1)	 		//resolution is higher than 2, can check current edge values
			  	if (!(QEC_ENC_CHAN_A == prev_value_A))  {	//CCR 0.0
			  		QEC_update_encoder_position_A();
				}
			  #if (QEC_J9_ENCODER_POSITION_TRACKING == 1)
				if (!(QEC_enc_chan_B == prev_value_B))  {	//CCR 0.1 -- only need to check if two encoders are used
			  #else
			  	else {
			  #endif
			  		QEC_update_encoder_position_B();
				}
			#else							   //resolution is lower than 2, must check interrupt flag
				#if (QEC_J9_ENCODER_POSITION_TRACKING == 0)
					QEC_update_encoder_position_A();
				#else
					if ((T0IR & 0<<4)>>4) {
						QEC_update_encoder_position_A();
					}	
				#endif
			#endif						
		#endif
		#if QEC_J9_ENCODER_POSITION_TRACKING
			#if (QEC_J9_RESOLUTION > 1)			//resolution is higher than 2, can check current edge values
				if (!(QEC_enc_chan_C == prev_value_C))  {	//CCR 0.2
			  		QEC_update_encoder_position_C();
				}
			  	else {
			  		QEC_update_encoder_position_D();
				}
			#else								//resolution is lower than 2, check interrupt flags
				#if (QEC_J3_ENCODER_POSITION_TRACKING == 0)
					QEC_update_encoder_position_C();
				#else
					else {
						QEC_update_encoder_position_C();	
					}
				#endif
			#endif
		#endif
	  }
	  else {
    //Check if timer overflow occured before last service routine:
		//Check for overflow after Cap.0 and Cap.1 Events:
		  #if QEC_J3_ENCODER_VELOCITY_TRACKING
		  	#if (QEC_J3_RESOLUTION > 1)	 		//resolution is higher than 2, can check current edge values		     
				if (!(QEC_ENC_CHAN_A == prev_value_A))  {	//check if timer and CCR are active
					if (T0CR0 > T0TC) {
						QEC_update_encoder_position_A(); 
					}
					else {
						QEC_time_counter();
						VICVectAddr = 0;		//Acknowledge interrupt.
						return;
					}
				}
				if (!(QEC_enc_chan_B == prev_value_B))  {	//check if timer and CCR are active
					if (T0CR1 > T0TC) {
						QEC_update_encoder_position_B();					
					}
					else {
						QEC_time_counter();
						VICVectAddr = 0;		//Acknowledge interrupt.
						return;
					}
				}
			#else 								//resolution is lower than 2, check interrupt flags
				if ((T0IR & 1<<4)>>4)  {
					if (T0CR0 > T0TC) {
						QEC_update_encoder_position_A(); 
					}
					else {
						QEC_time_counter();
						VICVectAddr = 0;		//Acknowledge interrupt.
						FIO0SET = (1<<10);	// p0.10 off
						return;
					}
				}
			#endif
		  #endif
		//Check for overflow after Cap.1 and Cap.2 Events:
		  #if QEC_J9_ENCODER_VELOCITY_TRACKING
				if (!(QEC_enc_chan_C == prev_value_C))  {	//check if timer and CCR are active
					if (T0CR2 > T0TC) {
						QEC_update_encoder_position_C(); 
					}
					else {
						QEC_time_counter();
						VICVectAddr = 0;		//Acknowledge interrupt.
						FIO0SET_bit.P0_10=1;	// p0.10 off
						return;
					}
				}
				if (!(QEC_enc_chan_D == prev_value_D))  {	//check if timer and CCR are active
					if (T0CR3 > T0TC) {
						QEC_update_encoder_position_D();					
					}
					else {
						QEC_time_counter();
						VICVectAddr = 0;		//Acknowledge interrupt.
						FIO0SET_bit.P0_10=1;	// p0.10 off
						return;
					}
				}
		  #endif
		//Otherwise run QEC_time_counter routine:
		  #if (QEC_J9_ENCODER_VELOCITY_TRACKING | QEC_J3_ENCODER_VELOCITY_TRACKING)
				else {
					QEC_time_counter();
				}
		  #else
		  		QEC_time_counter();
		  #endif	  
	  }

		qec_interrupt_count++;

	//Acknowlegde Interrupt:
		VICVectAddr = 0;		//Acknowledge interrupt.
//		FIO0SET_bit.P0_10=1;	// p0.10 off
} 

int QEC_get_interrupt_count(void)
{
	int temp1 = qec_interrupt_count;
	int delta = temp1 - qec_last_count;
	qec_last_count = temp1;
	return delta;
}

//Check For Improper Macro Settings:
	#if QEC_J3_ENCODER_VELOCITY_TRACKING
		#if !QEC_J3_ENCODER_POSITION_TRACKING
			#error Position tracking must be enabled when velocity tracking is enabled (change QEC_J3_ENCODER_POSITION_TRACKING setting)!
		#endif
	#endif 
	#if QEC_J9_ENCODER_VELOCITY_TRACKING
		#if !QEC_J9_ENCODER_POSITION_TRACKING
			#error Position tracking must be enabled when velocity tracking is enabled (change QEC_J9_ENCODER_POSITION_TRACKING setting)!
		#endif
	#endif
	#if ((QEC_J3_RESOLUTION < 1) | (QEC_J3_RESOLUTION > 4))
		#error Invalid resolution for J3 encoder...must be from 1-4!
	#endif
	#if ((QEC_J9_RESOLUTION < 1) | (QEC_J9_RESOLUTION > 4))
		#error Invalid resolution for J9 encoder...must be from 1-4!
	#endif


